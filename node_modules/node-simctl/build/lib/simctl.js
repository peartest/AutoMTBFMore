"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.installApp = installApp;
exports.removeApp = removeApp;
exports.launch = launch;
exports.spawn = spawn;
exports.spawnSubProcess = spawnSubProcess;
exports.openUrl = openUrl;
exports.terminate = terminate;
exports.shutdown = shutdown;
exports.createDevice = createDevice;
exports.getAppContainer = getAppContainer;
exports.getScreenshot = getScreenshot;
exports.deleteDevice = deleteDevice;
exports.eraseDevice = eraseDevice;
exports.getDevices = getDevices;
exports.getRuntimeForPlatformVersion = getRuntimeForPlatformVersion;
exports.bootDevice = bootDevice;
exports.setPasteboard = setPasteboard;
exports.getPasteboard = getPasteboard;
exports.addMedia = addMedia;
exports.appInfo = appInfo;
exports.getDeviceTypes = getDeviceTypes;
exports.startBootMonitor = startBootMonitor;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _teen_process = require("teen_process");

var _asyncbox = require("asyncbox");

var _appiumSupport = require("appium-support");

var _lodash = _interopRequireDefault(require("lodash"));

const log = _appiumSupport.logger.getLogger('simctl');

const IOS_RUNTIME_REGEXP = /iOS (\d+\.\d+) \((\d+\.\d+\.*\d*)/;

function simCommand(_x, _x2) {
  return _simCommand.apply(this, arguments);
}

function _simCommand() {
  _simCommand = (0, _asyncToGenerator2.default)(function* (command, timeout, args = [], env = {}, executingFunction = _teen_process.exec, logErrors = true) {
    args = ['simctl', command, ...args];
    env = _lodash.default.defaults(_lodash.default.mapKeys(env, (value, key) => {
      return `SIMCTL_CHILD_${key}`;
    }), process.env);

    try {
      return yield executingFunction('xcrun', args, {
        timeout,
        env
      });
    } catch (e) {
      if (!logErrors) {
        throw e;
      } else if (e.stderr) {
        log.errorAndThrow(`simctl error running '${command}': ${e.stderr.trim()}`);
      } else {
        log.errorAndThrow(e);
      }
    }
  });
  return _simCommand.apply(this, arguments);
}

function simExec(_x3, _x4) {
  return _simExec.apply(this, arguments);
}

function _simExec() {
  _simExec = (0, _asyncToGenerator2.default)(function* (command, timeout, args = [], env = {}, logErrors = true) {
    return yield simCommand(command, timeout, args, env, function () {
      var _ref = (0, _asyncToGenerator2.default)(function* (c, a, ob) {
        return yield (0, _teen_process.exec)(c, a, ob);
      });

      return function (_x40, _x41, _x42) {
        return _ref.apply(this, arguments);
      };
    }(), logErrors);
  });
  return _simExec.apply(this, arguments);
}

function simSubProcess(_x5, _x6) {
  return _simSubProcess.apply(this, arguments);
}

function _simSubProcess() {
  _simSubProcess = (0, _asyncToGenerator2.default)(function* (command, timeout, args = [], env = {}) {
    return yield simCommand(command, timeout, args, env, (c, a, ob) => {
      return new _teen_process.SubProcess(c, a, ob);
    });
  });
  return _simSubProcess.apply(this, arguments);
}

function installApp(_x7, _x8) {
  return _installApp.apply(this, arguments);
}

function _installApp() {
  _installApp = (0, _asyncToGenerator2.default)(function* (udid, appPath) {
    yield simExec('install', 0, [udid, appPath]);
  });
  return _installApp.apply(this, arguments);
}

function bootDevice(_x9) {
  return _bootDevice.apply(this, arguments);
}

function _bootDevice() {
  _bootDevice = (0, _asyncToGenerator2.default)(function* (udid) {
    try {
      yield simExec('boot', 0, [udid]);
    } catch (err) {
      if ((err.message || '').indexOf('Unable to boot device in current state: Booted') === -1) {
        throw err;
      }

      log.debug(`Simulator already in 'Booted' state. Continuing`);
    }
  });
  return _bootDevice.apply(this, arguments);
}

function removeApp(_x10, _x11) {
  return _removeApp.apply(this, arguments);
}

function _removeApp() {
  _removeApp = (0, _asyncToGenerator2.default)(function* (udid, bundleId) {
    yield simExec('uninstall', 0, [udid, bundleId]);
  });
  return _removeApp.apply(this, arguments);
}

function launch(_x12, _x13) {
  return _launch.apply(this, arguments);
}

function _launch() {
  _launch = (0, _asyncToGenerator2.default)(function* (udid, bundleId, tries = 5) {
    yield (0, _asyncbox.retryInterval)(tries, 1000, (0, _asyncToGenerator2.default)(function* () {
      yield simExec('launch', 0, [udid, bundleId]);
    }));
  });
  return _launch.apply(this, arguments);
}

function spawn(_x14, _x15) {
  return _spawn.apply(this, arguments);
}

function _spawn() {
  _spawn = (0, _asyncToGenerator2.default)(function* (udid, args, env = {}) {
    return yield simExec('spawn', 0, [udid, ...(_lodash.default.isArray(args) ? args : [args])], env);
  });
  return _spawn.apply(this, arguments);
}

function spawnSubProcess(_x16, _x17) {
  return _spawnSubProcess.apply(this, arguments);
}

function _spawnSubProcess() {
  _spawnSubProcess = (0, _asyncToGenerator2.default)(function* (udid, args, env = {}) {
    return yield simSubProcess('spawn', 0, [udid, ...(_lodash.default.isArray(args) ? args : [args])], env);
  });
  return _spawnSubProcess.apply(this, arguments);
}

function openUrl(_x18, _x19) {
  return _openUrl.apply(this, arguments);
}

function _openUrl() {
  _openUrl = (0, _asyncToGenerator2.default)(function* (udid, url) {
    return yield simExec('openurl', 0, [udid, url]);
  });
  return _openUrl.apply(this, arguments);
}

function appInfo(_x20, _x21) {
  return _appInfo.apply(this, arguments);
}

function _appInfo() {
  _appInfo = (0, _asyncToGenerator2.default)(function* (udid, bundleId) {
    const _ref3 = yield simExec('appinfo', 0, [udid, bundleId]),
          stdout = _ref3.stdout;

    return (stdout || '').trim();
  });
  return _appInfo.apply(this, arguments);
}

function addMedia(_x22, _x23) {
  return _addMedia.apply(this, arguments);
}

function _addMedia() {
  _addMedia = (0, _asyncToGenerator2.default)(function* (udid, path) {
    return yield simExec('addmedia', 0, [udid, path]);
  });
  return _addMedia.apply(this, arguments);
}

function terminate(_x24, _x25) {
  return _terminate.apply(this, arguments);
}

function _terminate() {
  _terminate = (0, _asyncToGenerator2.default)(function* (udid, bundleId) {
    yield simExec('terminate', 0, [udid, bundleId]);
  });
  return _terminate.apply(this, arguments);
}

function getAppContainer(_x26, _x27) {
  return _getAppContainer.apply(this, arguments);
}

function _getAppContainer() {
  _getAppContainer = (0, _asyncToGenerator2.default)(function* (udid, bundleId, logErrors = true, containerType = null) {
    const args = [udid, bundleId];

    if (containerType) {
      args.push(containerType);
    }

    const _ref4 = yield simExec('get_app_container', 0, args, {}, logErrors),
          stdout = _ref4.stdout;

    return (stdout || '').trim();
  });
  return _getAppContainer.apply(this, arguments);
}

function shutdown(_x28) {
  return _shutdown.apply(this, arguments);
}

function _shutdown() {
  _shutdown = (0, _asyncToGenerator2.default)(function* (udid) {
    try {
      yield simExec('shutdown', 0, [udid]);
    } catch (err) {
      if (!(err + '').includes('current state: Shutdown')) {
        throw err;
      }

      log.debug(`Simulator already in 'Shutdown' state. Continuing`);
    }
  });
  return _shutdown.apply(this, arguments);
}

function createDevice(_x29, _x30, _x31) {
  return _createDevice.apply(this, arguments);
}

function _createDevice() {
  _createDevice = (0, _asyncToGenerator2.default)(function* (name, deviceTypeId, runtimeId, timeout = 10000) {
    let udid;

    try {
      runtimeId = yield getRuntimeForPlatformVersion(runtimeId);
    } catch (err) {
      log.warn(`Unable to find runtime for iOS '${runtimeId}'. Continuing`);
    }

    log.debug(`Creating simulator with name '${name}', device type id '${deviceTypeId}' and runtime id '${runtimeId}'`);

    try {
      let out = yield simExec('create', 0, [name, deviceTypeId, runtimeId]);
      udid = out.stdout.trim();
    } catch (err) {
      let reason = err.message;

      if (err.stderr) {
        reason = err.stderr.trim();
      }

      log.errorAndThrow(`Could not create simulator with name '${name}', device ` + `type id '${deviceTypeId}' and runtime id '${runtimeId}'. Reason: '${reason}'`);
    }

    let retries = parseInt(timeout / 1000, 10);
    yield (0, _asyncbox.retryInterval)(retries, 1000, (0, _asyncToGenerator2.default)(function* () {
      let devices = yield getDevices();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _lodash.default.values(devices)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          let deviceArr = _step.value;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = deviceArr[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              let device = _step2.value;

              if (device.udid === udid) {
                if (device.state === 'Creating') {
                  throw new Error('Device still being created');
                } else {
                  return;
                }
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }));
    return udid;
  });
  return _createDevice.apply(this, arguments);
}

function deleteDevice(_x32) {
  return _deleteDevice.apply(this, arguments);
}

function _deleteDevice() {
  _deleteDevice = (0, _asyncToGenerator2.default)(function* (udid) {
    yield simExec('delete', 0, [udid]);
  });
  return _deleteDevice.apply(this, arguments);
}

function eraseDevice(_x33) {
  return _eraseDevice.apply(this, arguments);
}

function _eraseDevice() {
  _eraseDevice = (0, _asyncToGenerator2.default)(function* (udid, timeout = 1000) {
    let loopFn = function () {
      var _ref6 = (0, _asyncToGenerator2.default)(function* () {
        yield simExec('erase', 10000, [udid]);
      });

      return function loopFn() {
        return _ref6.apply(this, arguments);
      };
    }();

    let retries = parseInt(timeout / 200, 10);
    yield (0, _asyncbox.retryInterval)(retries, 200, loopFn);
  });
  return _eraseDevice.apply(this, arguments);
}

function getDevicesByParsing() {
  return _getDevicesByParsing.apply(this, arguments);
}

function _getDevicesByParsing() {
  _getDevicesByParsing = (0, _asyncToGenerator2.default)(function* () {
    let _ref7 = yield simExec('list', 0, ['devices']),
        stdout = _ref7.stdout;

    let deviceSectionRe = /-- iOS (.+) --(\n\s{4}.+)*/mg;
    let matches = [];
    let match = deviceSectionRe.exec(stdout);

    while (match !== null) {
      matches.push(match);
      match = deviceSectionRe.exec(stdout);
    }

    if (matches.length < 1) {
      log.errorAndThrow('Could not find device section');
    }

    let devices = {};

    for (var _i = 0; _i < matches.length; _i++) {
      match = matches[_i];
      let sdk = match[1];
      devices[sdk] = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = match[0].split('\n').slice(1)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          let line = _step3.value;
          let lineRe = /([^\s].+) \((\w+-.+\w+)\) \((\w+\s?\w+)\)/;
          let lineMatch = lineRe.exec(line);

          if (lineMatch === null) {
            throw new Error(`Could not match line: ${line}`);
          }

          devices[sdk].push({
            name: lineMatch[1],
            udid: lineMatch[2],
            state: lineMatch[3],
            sdk
          });
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    return devices;
  });
  return _getDevicesByParsing.apply(this, arguments);
}

function getDevices() {
  return _getDevices.apply(this, arguments);
}

function _getDevices() {
  _getDevices = (0, _asyncToGenerator2.default)(function* (forSdk = null) {
    let devices;

    try {
      let _ref8 = yield simExec('list', 0, ['devices', '-j']),
          stdout = _ref8.stdout;

      devices = {};
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = _lodash.default.toPairs(JSON.parse(stdout).devices)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          let _step4$value = (0, _slicedToArray2.default)(_step4.value, 2),
              sdkName = _step4$value[0],
              entries = _step4$value[1];

          if (sdkName.indexOf('iOS') !== 0) {
            continue;
          }

          let sdk = sdkName.replace('iOS ', '');
          devices[sdk] = entries.map(el => {
            delete el.availability;
            return (0, _objectSpread2.default)({}, el, {
              sdk
            });
          });
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    } catch (err) {
      log.debug(`Unable to get JSON device list: ${err.message}`);
      log.debug('Falling back to manually parsing');
      devices = yield getDevicesByParsing();
    }

    if (forSdk) {
      if (!devices[forSdk]) {
        let errMsg = `'${forSdk}' does not exist in the list of simctl SDKs.`;

        const availableSDKs = _lodash.default.keys(devices);

        errMsg += availableSDKs.length ? ` Only the following Simulator SDK versions are available on your system: ${availableSDKs.join(', ')}` : ` No Simulator SDK versions are available on your system. Please install some via Xcode preferences.`;
        throw new Error(errMsg);
      }

      return devices[forSdk];
    }

    return devices;
  });
  return _getDevices.apply(this, arguments);
}

function getRuntimeForPlatformVersion(_x34) {
  return _getRuntimeForPlatformVersion.apply(this, arguments);
}

function _getRuntimeForPlatformVersion() {
  _getRuntimeForPlatformVersion = (0, _asyncToGenerator2.default)(function* (platformVersion) {
    try {
      let _ref9 = yield simExec('list', 0, ['runtimes']),
          stdout = _ref9.stdout;

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = stdout.split('\n')[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          let line = _step5.value;
          let match = IOS_RUNTIME_REGEXP.exec(line);

          if (match) {
            if (match[1] === platformVersion) {
              return match[2];
            }
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    } catch (ign) {}

    return platformVersion;
  });
  return _getRuntimeForPlatformVersion.apply(this, arguments);
}

function getScreenshot(_x35) {
  return _getScreenshot.apply(this, arguments);
}

function _getScreenshot() {
  _getScreenshot = (0, _asyncToGenerator2.default)(function* (udid) {
    let pathToScreenshotPng = yield _appiumSupport.tempDir.path({
      prefix: `screenshot-${udid}`,
      suffix: '.png'
    });
    yield simExec('io', 0, [udid, 'screenshot', pathToScreenshotPng]);
    let screenshotImg = yield _appiumSupport.fs.readFile(pathToScreenshotPng);
    yield _appiumSupport.fs.rimraf(pathToScreenshotPng);
    return screenshotImg.toString('base64');
  });
  return _getScreenshot.apply(this, arguments);
}

function setPasteboard(_x36, _x37) {
  return _setPasteboard.apply(this, arguments);
}

function _setPasteboard() {
  _setPasteboard = (0, _asyncToGenerator2.default)(function* (udid, content, encoding = 'utf-8') {
    const pbCopySubprocess = new _teen_process.SubProcess('xcrun', ['simctl', 'pbcopy', udid]);
    yield pbCopySubprocess.start(0);
    const exitCodeVerifier = pbCopySubprocess.join();
    const stdin = pbCopySubprocess.proc.stdin;
    stdin.setEncoding(encoding);
    stdin.write(content);
    stdin.end();
    yield exitCodeVerifier;
  });
  return _setPasteboard.apply(this, arguments);
}

function getPasteboard(_x38) {
  return _getPasteboard.apply(this, arguments);
}

function _getPasteboard() {
  _getPasteboard = (0, _asyncToGenerator2.default)(function* (udid, encoding = 'utf-8') {
    const args = ['simctl', 'pbpaste', udid];

    try {
      const _ref10 = yield (0, _teen_process.exec)('xcrun', args, {
        timeout: 0,
        encoding
      }),
            stdout = _ref10.stdout;

      return stdout;
    } catch (e) {
      if (e.stderr) {
        log.errorAndThrow(`Error running 'xcrun ${args.join(' ')}': ${e.stderr.trim()}`);
      } else {
        log.errorAndThrow(e);
      }
    }
  });
  return _getPasteboard.apply(this, arguments);
}

function getDeviceTypes() {
  return _getDeviceTypes.apply(this, arguments);
}

function _getDeviceTypes() {
  _getDeviceTypes = (0, _asyncToGenerator2.default)(function* () {
    try {
      const _ref11 = yield simExec('list', 0, ['devicetypes', '-j']),
            stdout = _ref11.stdout;

      const deviceTypes = JSON.parse(stdout.trim());
      return deviceTypes.devicetypes.map(type => type.name);
    } catch (err) {
      let msg = `Unable to get list of device types: ${err.message}`;

      if (err.stderr) {
        msg = `${msg}. Stderr: ${err.stderr}`;
      }

      throw new Error(msg);
    }
  });
  return _getDeviceTypes.apply(this, arguments);
}

function startBootMonitor(_x39) {
  return _startBootMonitor.apply(this, arguments);
}

function _startBootMonitor() {
  _startBootMonitor = (0, _asyncToGenerator2.default)(function* (udid, opts = {}) {
    const _opts$timeout = opts.timeout,
          timeout = _opts$timeout === void 0 ? 240000 : _opts$timeout,
          onWaitingDataMigration = opts.onWaitingDataMigration,
          onWaitingSystemApp = opts.onWaitingSystemApp,
          onFinished = opts.onFinished,
          onError = opts.onError;
    let status = '';
    let isBootingFinished = false;
    let error = null;
    let timeoutHandler = null;
    const bootMonitor = yield simSubProcess('bootstatus', 0, [udid]);
    bootMonitor.on('output', (stdout, stderr) => {
      status += stdout || stderr;

      if (stdout) {
        if (stdout.includes('Waiting on Data Migration') && onWaitingDataMigration) {
          onWaitingDataMigration();
        } else if (stdout.includes('Waiting on System App') && onWaitingSystemApp) {
          onWaitingSystemApp();
        }
      }
    });
    bootMonitor.on('exit', (code, signal) => {
      if (timeoutHandler) {
        clearTimeout(timeoutHandler);
      }

      if (code === 0) {
        if (onFinished) {
          onFinished();
        }

        isBootingFinished = true;
      } else {
        status = status || signal;
        error = new Error(status);

        if (onError) {
          onError(error);
        }
      }
    });
    yield bootMonitor.start(0);

    const stopMonitor = function () {
      var _ref12 = (0, _asyncToGenerator2.default)(function* () {
        if (bootMonitor.isRunning) {
          try {
            yield bootMonitor.stop();
          } catch (e) {
            log.warn(e.message);
          }
        }
      });

      return function stopMonitor() {
        return _ref12.apply(this, arguments);
      };
    }();

    const timeStarted = process.hrtime();

    if (onFinished) {
      timeoutHandler = setTimeout(stopMonitor, timeout);
    } else {
      try {
        yield (0, _asyncbox.waitForCondition)(() => {
          if (error) {
            throw error;
          }

          return isBootingFinished;
        }, {
          waitMs: timeout,
          intervalMs: 500
        });
      } catch (err) {
        yield stopMonitor();
        throw new Error(`The simulator ${udid} has failed to finish booting after ${process.hrtime(timeStarted)[0]}s. ` + `Original status: ${status}`);
      }
    }

    return bootMonitor;
  });
  return _startBootMonitor.apply(this, arguments);
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9zaW1jdGwuanMiXSwibmFtZXMiOlsibG9nIiwibG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiSU9TX1JVTlRJTUVfUkVHRVhQIiwic2ltQ29tbWFuZCIsImNvbW1hbmQiLCJ0aW1lb3V0IiwiYXJncyIsImVudiIsImV4ZWN1dGluZ0Z1bmN0aW9uIiwiZXhlYyIsImxvZ0Vycm9ycyIsIl8iLCJkZWZhdWx0cyIsIm1hcEtleXMiLCJ2YWx1ZSIsImtleSIsInByb2Nlc3MiLCJlIiwic3RkZXJyIiwiZXJyb3JBbmRUaHJvdyIsInRyaW0iLCJzaW1FeGVjIiwiYyIsImEiLCJvYiIsInNpbVN1YlByb2Nlc3MiLCJTdWJQcm9jZXNzIiwiaW5zdGFsbEFwcCIsInVkaWQiLCJhcHBQYXRoIiwiYm9vdERldmljZSIsImVyciIsIm1lc3NhZ2UiLCJpbmRleE9mIiwiZGVidWciLCJyZW1vdmVBcHAiLCJidW5kbGVJZCIsImxhdW5jaCIsInRyaWVzIiwic3Bhd24iLCJpc0FycmF5Iiwic3Bhd25TdWJQcm9jZXNzIiwib3BlblVybCIsInVybCIsImFwcEluZm8iLCJzdGRvdXQiLCJhZGRNZWRpYSIsInBhdGgiLCJ0ZXJtaW5hdGUiLCJnZXRBcHBDb250YWluZXIiLCJjb250YWluZXJUeXBlIiwicHVzaCIsInNodXRkb3duIiwiaW5jbHVkZXMiLCJjcmVhdGVEZXZpY2UiLCJuYW1lIiwiZGV2aWNlVHlwZUlkIiwicnVudGltZUlkIiwiZ2V0UnVudGltZUZvclBsYXRmb3JtVmVyc2lvbiIsIndhcm4iLCJvdXQiLCJyZWFzb24iLCJyZXRyaWVzIiwicGFyc2VJbnQiLCJkZXZpY2VzIiwiZ2V0RGV2aWNlcyIsInZhbHVlcyIsImRldmljZUFyciIsImRldmljZSIsInN0YXRlIiwiRXJyb3IiLCJkZWxldGVEZXZpY2UiLCJlcmFzZURldmljZSIsImxvb3BGbiIsImdldERldmljZXNCeVBhcnNpbmciLCJkZXZpY2VTZWN0aW9uUmUiLCJtYXRjaGVzIiwibWF0Y2giLCJsZW5ndGgiLCJzZGsiLCJzcGxpdCIsInNsaWNlIiwibGluZSIsImxpbmVSZSIsImxpbmVNYXRjaCIsImZvclNkayIsInRvUGFpcnMiLCJKU09OIiwicGFyc2UiLCJzZGtOYW1lIiwiZW50cmllcyIsInJlcGxhY2UiLCJtYXAiLCJlbCIsImF2YWlsYWJpbGl0eSIsImVyck1zZyIsImF2YWlsYWJsZVNES3MiLCJrZXlzIiwiam9pbiIsInBsYXRmb3JtVmVyc2lvbiIsImlnbiIsImdldFNjcmVlbnNob3QiLCJwYXRoVG9TY3JlZW5zaG90UG5nIiwidGVtcERpciIsInByZWZpeCIsInN1ZmZpeCIsInNjcmVlbnNob3RJbWciLCJmcyIsInJlYWRGaWxlIiwicmltcmFmIiwidG9TdHJpbmciLCJzZXRQYXN0ZWJvYXJkIiwiY29udGVudCIsImVuY29kaW5nIiwicGJDb3B5U3VicHJvY2VzcyIsInN0YXJ0IiwiZXhpdENvZGVWZXJpZmllciIsInN0ZGluIiwicHJvYyIsInNldEVuY29kaW5nIiwid3JpdGUiLCJlbmQiLCJnZXRQYXN0ZWJvYXJkIiwiZ2V0RGV2aWNlVHlwZXMiLCJkZXZpY2VUeXBlcyIsImRldmljZXR5cGVzIiwidHlwZSIsIm1zZyIsInN0YXJ0Qm9vdE1vbml0b3IiLCJvcHRzIiwib25XYWl0aW5nRGF0YU1pZ3JhdGlvbiIsIm9uV2FpdGluZ1N5c3RlbUFwcCIsIm9uRmluaXNoZWQiLCJvbkVycm9yIiwic3RhdHVzIiwiaXNCb290aW5nRmluaXNoZWQiLCJlcnJvciIsInRpbWVvdXRIYW5kbGVyIiwiYm9vdE1vbml0b3IiLCJvbiIsImNvZGUiLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJzdG9wTW9uaXRvciIsImlzUnVubmluZyIsInN0b3AiLCJ0aW1lU3RhcnRlZCIsImhydGltZSIsInNldFRpbWVvdXQiLCJ3YWl0TXMiLCJpbnRlcnZhbE1zIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNQSxHQUFHLEdB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LE9BUmdCOztBQUFBLHNCQUFYK0csV0FBVztBQUFBO0FBQUE7QUFBQSxPQUFqQjs7QUFTQSxVQUFNRyxXQUFXLEdBQUdsSSxPQUFPLENBQUNtSSxNQUFSLEVBQXBCOztBQUNBLFFBQUlmLFVBQUosRUFBZ0I7QUFDZEssTUFBQUEsY0FBYyxHQUFHVyxVQUFVLENBQUNMLFdBQUQsRUFBYzFJLE9BQWQsQ0FBM0I7QUFDRCxLQUZELE1BRU87QUFDTCxVQUFJO0FBQ0YsY0FBTSxnQ0FBaUIsTUFBTTtBQUMzQixjQUFJbUksS0FBSixFQUFXO0FBQ1Qsa0JBQU1BLEtBQU47QUFDRDs7QUFDRCxpQkFBT0QsaUJBQVA7QUFDRCxTQUxLLEVBS0g7QUFBQ2MsVUFBQUEsTUFBTSxFQUFFaEosT0FBVDtBQUFrQmlKLFVBQUFBLFVBQVUsRUFBRTtBQUE5QixTQUxHLENBQU47QUFNRCxPQVBELENBT0UsT0FBT3ZILEdBQVAsRUFBWTtBQUNaLGNBQU1nSCxXQUFXLEVBQWpCO0FBQ0EsY0FBTSxJQUFJekUsS0FBSixDQUFXLGlCQUFnQjFDLElBQUssdUNBQXNDWixPQUFPLENBQUNtSSxNQUFSLENBQWVELFdBQWYsRUFBNEIsQ0FBNUIsQ0FBK0IsS0FBM0YsR0FDYixvQkFBbUJaLE1BQU8sRUFEdkIsQ0FBTjtBQUVEO0FBQ0Y7O0FBQ0QsV0FBT0ksV0FBUDtBQUNELEciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGVjLCBTdWJQcm9jZXNzIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IHJldHJ5SW50ZXJ2YWwsIHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyBsb2dnZXIsIGZzLCB0ZW1wRGlyIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgbG9nID0gbG9nZ2VyLmdldExvZ2dlcignc2ltY3RsJyk7XG5cbi8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvVXlralFaLzFcbmNvbnN0IElPU19SVU5USU1FX1JFR0VYUCA9IC9pT1MgKFxcZCtcXC5cXGQrKSBcXCgoXFxkK1xcLlxcZCtcXC4qXFxkKikvO1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIHBhcnRpY3VsYXIgc2ltY3RsIGNvbW1hbmQgYW5kIHJldHVybiB0aGUgb3V0cHV0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21tYW5kIC0gT25lIG9mIGF2YWlsYWJsZSBzaW1jdGwgc3ViY29tbWFuZHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIEV4ZWN1dGUgYHhjcnVuIHNpbWN0bGAgaW4gVGVybWluYWwgdG8gc2VlIHRoZSBmdWxsIGxpc3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgYXZhaWxhYmxlIHN1YmNvbW1hbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgLSBDb21tYW5kIGV4ZWN1dGlvbiB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0IGl0IHRvIHplcm8gdG8gc2tpcCB3YWl0aW5nIGZvciBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbi5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGFyZ3MgW1tdXSAtIFRoZSBsaXN0IG9mIGFkZGl0aW9uYWwgc3ViY29tbWFuZCBhcmd1bWVudHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCdzIGVtcHR5IGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0ge09iamVjdH0gZW52IFt7fV0gLSBFbnZpcm9ubWVudCB2YXJpYWJsZXMgbWFwcGluZy4gQWxsIHRoZXNlIHZhcmlhYmxlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBwYXNzZWQgU2ltdWxhdG9yIGFuZCB1c2VkIGluIF9leGVjdXRpbmdGdW5jdGlvbl8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRpbmdGdW5jdGlvbiAtIEV4ZWN1dGluZyBmdW5jdGlvbiBvYmplY3QuIEVxdWFscyB0byB0ZWVuX3Byb2Nlc3Mnc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZXhlY18gYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9nRXJyb3JzIFt0cnVlXSAtIFNldCBpdCB0byBfZmFsc2VfIHRvIHRocm93IGV4ZWN1dGlvbiBlcnJvcnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5IHdpdGhvdXQgbG9nZ2luZyBhbnkgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdCBvZiBfZXhlY3V0aW5nRnVuY3Rpb25fLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kIGV4ZWN1dGVkIGJ5IF9leGVjdXRpbmdGdW5jdGlvbl9cbiAqICAgICAgICAgICAgICAgICByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaW1Db21tYW5kIChjb21tYW5kLCB0aW1lb3V0LCBhcmdzID0gW10sIGVudiA9IHt9LCBleGVjdXRpbmdGdW5jdGlvbiA9IGV4ZWMsIGxvZ0Vycm9ycyA9IHRydWUpIHtcbiAgLy8gcnVuIGEgcGFydGljdWxhciBzaW1jdGwgY29tbWFuZFxuICBhcmdzID0gWydzaW1jdGwnLCBjb21tYW5kLCAuLi5hcmdzXTtcbiAgLy8gUHJlZml4IGFsbCBwYXNzZWQgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpdGggJ1NJTUNUTF9DSElMRF8nLCBzaW1jdGxcbiAgLy8gd2lsbCB0aGVuIHBhc3MgdGhlc2UgdG8gdGhlIGNoaWxkIChzcGF3bmVkKSBwcm9jZXNzLlxuICBlbnYgPSBfLmRlZmF1bHRzKF8ubWFwS2V5cyhlbnYsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgcmV0dXJuIGBTSU1DVExfQ0hJTERfJHtrZXl9YDtcbiAgfSksIHByb2Nlc3MuZW52KTtcblxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBleGVjdXRpbmdGdW5jdGlvbigneGNydW4nLCBhcmdzLCB7dGltZW91dCwgZW52fSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIWxvZ0Vycm9ycykge1xuICAgICAgLy8gaWYgd2UgZG9uJ3Qgd2FudCB0byBzZWUgdGhlIGVycm9ycywganVzdCB0aHJvdyBhbmQgYWxsb3cgdGhlIGNhbGxpbmdcbiAgICAgIC8vIGNvZGUgZG8gd2hhdCBpdCB3YW50c1xuICAgICAgdGhyb3cgZTtcbiAgICB9IGVsc2UgaWYgKGUuc3RkZXJyKSB7XG4gICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgc2ltY3RsIGVycm9yIHJ1bm5pbmcgJyR7Y29tbWFuZH0nOiAke2Uuc3RkZXJyLnRyaW0oKX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3coZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRXhlY1Jlc3VsdFxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBzdGRvdXQgLSBQcm9jZXNzIHN0ZG91dC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gc3RkZXJyIC0gUHJvY2VzcyBzdGRlcnIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIFByb2Nlc3MgZXhpdCBjb2RlLlxuICovXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgcGFydGljdWxhciBzaW1jdGwgc3ViY29tbWFuZCBzeW5jaHJvbm91c2x5IGFuZFxuICogd2FpdCBmb3IgdGhlIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZCAtIFNlZSB7QGxpbmsgc2ltQ29tbWFuZH0gcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IC0gU2VlIHtAbGluayBzaW1Db21tYW5kfSBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gYXJncyBbW11dIC0gU2VlIHtAbGluayBzaW1Db21tYW5kfSBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IGVudiBbe31dIC0gU2VlIHtAbGluayBzaW1Db21tYW5kfSBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtib29sZWFufSBsb2dFcnJvcnMgW3RydWVdIC0gU2VlIHtAbGluayBzaW1Db21tYW5kfSBwYXJhbWV0ZXJzLlxuICogQHJldHVybiB7RXhlY1Jlc3VsdH0gVGhlIHJlc3VsdCBvZiBfZXhlY18gZnVuY3Rpb24uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNpbWN0bCBzdWJjb21tYW5kIGNvbW1hbmQgZXhlY3V0ZWQgYnkgZXhlY1xuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpbUV4ZWMgKGNvbW1hbmQsIHRpbWVvdXQsIGFyZ3MgPSBbXSwgZW52ID0ge30sIGxvZ0Vycm9ycyA9IHRydWUpIHtcbiAgcmV0dXJuIGF3YWl0IHNpbUNvbW1hbmQoY29tbWFuZCwgdGltZW91dCwgYXJncywgZW52LCBhc3luYyAoYywgYSwgb2IpID0+IHtcbiAgICByZXR1cm4gYXdhaXQgZXhlYyhjLCBhLCBvYik7XG4gIH0sIGxvZ0Vycm9ycyk7XG59XG5cbi8qKlxuICogQ3JhdGUgYSB0ZWVuX3Byb2Nlc3MncyBTdWJQcm9jZXNzIGluc3RhbmNlIGZvciB0aGUgcGFydGljdWxhclxuICogc2ltY3RsIHN1YmNvbW1hbmQgZXhlY3V0aW9uLiBUaGlzIG1pZ2h0IGJlIG5lZWRlZCB0byBnYWluIGJldHRlclxuICogY29udHJvbCBvdmVyIHRoZSBleGVjdXRpb24gcHJvY2Vzcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZCAtIFNlZSB7QGxpbmsgc2ltQ29tbWFuZH0gcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IC0gU2VlIHtAbGluayBzaW1Db21tYW5kfSBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gYXJncyBbW11dIC0gU2VlIHtAbGluayBzaW1Db21tYW5kfSBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IGVudiBbe31dIC0gU2VlIHtAbGluayBzaW1Db21tYW5kfSBwYXJhbWV0ZXJzLlxuICogQHJldHVybiB7U3ViUHJvY2Vzc30gVGhlIGluc3RhbmNlIG9mIHRlZW5fcHJvY2VzcydzIFN1YlByb2Nlc3MgY2xhc3MuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpbVN1YlByb2Nlc3MgKGNvbW1hbmQsIHRpbWVvdXQsIGFyZ3MgPSBbXSwgZW52ID0ge30pIHtcbiAgcmV0dXJuIGF3YWl0IHNpbUNvbW1hbmQoY29tbWFuZCwgdGltZW91dCwgYXJncywgZW52LCAoYywgYSwgb2IpID0+IHtcbiAgICByZXR1cm4gbmV3IFN1YlByb2Nlc3MoYywgYSwgb2IpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJbnN0YWxsIHRoZSBwYXJ0aWN1bGFyIGFwcGxpY2F0aW9uIHBhY2thZ2Ugb24gU2ltdWxhdG9yLlxuICogSXQgaXMgcmVxdWlyZWQgdGhhdCBTaW11bGF0b3IgaXMgaW4gX2Jvb3RlZF8gc3RhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgVURJRCBvZiBhbiBleGlzdGluZyBTaW11bGF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBwUGF0aCAtIEZ1bGwgcGF0aCB0byAuYXBwIHBhY2thZ2UsIHdoaWNoIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvaW5nIHRvIGJlIGluc3RhbGxlZC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5zdGFsbEFwcCAodWRpZCwgYXBwUGF0aCkge1xuICBhd2FpdCBzaW1FeGVjKCdpbnN0YWxsJywgMCwgW3VkaWQsIGFwcFBhdGhdKTtcbn1cblxuLyoqXG4gKiBCb290IHRoZSBwYXJ0aWN1bGFyIFNpbXVsYXRvciBpZiBpdCBpcyBub3QgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFRoZSBVRElEIG9mIGFuIGV4aXN0aW5nIFNpbXVsYXRvci5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gYm9vdERldmljZSAodWRpZCkge1xuICB0cnkge1xuICAgIGF3YWl0IHNpbUV4ZWMoJ2Jvb3QnLCAwLCBbdWRpZF0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoKGVyci5tZXNzYWdlIHx8ICcnKS5pbmRleE9mKCdVbmFibGUgdG8gYm9vdCBkZXZpY2UgaW4gY3VycmVudCBzdGF0ZTogQm9vdGVkJykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgU2ltdWxhdG9yIGFscmVhZHkgaW4gJ0Jvb3RlZCcgc3RhdGUuIENvbnRpbnVpbmdgKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgcGFydGljdWxhciBhcHBsaWNhdGlvbiBwYWNrYWdlIGZyb20gU2ltdWxhdG9yLlxuICogSXQgaXMgcmVxdWlyZWQgdGhhdCBTaW11bGF0b3IgaXMgaW4gX2Jvb3RlZF8gc3RhdGUgYW5kXG4gKiB0aGUgYXBwbGljYXRpb24gd2l0aCBnaXZlbiBidW5kbGUgaWRlbnRpZmllciBpcyBhbHJlYWR5IGluc3RhbGxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFRoZSBVRElEIG9mIGFuIGV4aXN0aW5nIFNpbXVsYXRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBidW5kbGVJZCAtIEJ1bmRsZSBpZGVudGlmaWVyIG9mIHRoZSBhcHBsaWNhdGlvbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGlzIGdvaW5nIHRvIGJlIHJlbW92ZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZUFwcCAodWRpZCwgYnVuZGxlSWQpIHtcbiAgYXdhaXQgc2ltRXhlYygndW5pbnN0YWxsJywgMCwgW3VkaWQsIGJ1bmRsZUlkXSk7XG59XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgcGFydGljdWxhciBhcHBsaWNhdGlvbiBwYWNrYWdlIG9uIFNpbXVsYXRvci5cbiAqIEl0IGlzIHJlcXVpcmVkIHRoYXQgU2ltdWxhdG9yIGlzIGluIF9ib290ZWRfIHN0YXRlIGFuZFxuICogdGhlIGFwcGxpY2F0aW9uIHdpdGggZ2l2ZW4gYnVuZGxlIGlkZW50aWZpZXIgaXMgYWxyZWFkeSBpbnN0YWxsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgVURJRCBvZiBhbiBleGlzdGluZyBTaW11bGF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gYnVuZGxlSWQgLSBCdW5kbGUgaWRlbnRpZmllciBvZiB0aGUgYXBwbGljYXRpb24sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBpcyBnb2luZyB0byBiZSByZW1vdmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHRyaWVzIFs1XSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZXRyaWVzIGJlZm9yZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93aW5nIGFuIGV4Y2VwdGlvbi5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbGF1bmNoICh1ZGlkLCBidW5kbGVJZCwgdHJpZXMgPSA1KSB7XG4gIGF3YWl0IHJldHJ5SW50ZXJ2YWwodHJpZXMsIDEwMDAsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBzaW1FeGVjKCdsYXVuY2gnLCAwLCBbdWRpZCwgYnVuZGxlSWRdKTtcbiAgfSk7XG59XG5cbi8qKlxuICogU3Bhd24gdGhlIHBhcnRpY3VsYXIgcHJvY2VzcyBvbiBTaW11bGF0b3IuXG4gKiBJdCBpcyByZXF1aXJlZCB0aGF0IFNpbXVsYXRvciBpcyBpbiBfYm9vdGVkXyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFRoZSBVRElEIG9mIGFuIGV4aXN0aW5nIFNpbXVsYXRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IGFyZ3MgLSBTcGF3biBhcmd1bWVudHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBlbnYgW3t9XSAtIEFkZGl0aW9uYWwgZW52aXJvbm1lbnQgdmFyaWFibGVzIG1hcHBpbmcuXG4gKiBAcmV0dXJuIHtFeGVjUmVzdWx0fSBDb21tYW5kIGV4ZWN1dGlvbiByZXN1bHQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNwYXduICh1ZGlkLCBhcmdzLCBlbnYgPSB7fSkge1xuICByZXR1cm4gYXdhaXQgc2ltRXhlYygnc3Bhd24nLCAwLCBbdWRpZCwgLi4uKF8uaXNBcnJheShhcmdzKSA/IGFyZ3MgOiBbYXJnc10pXSwgZW52KTtcbn1cblxuLyoqXG4gKiBQcmVwYXJlIFN1YlByb2Nlc3MgaW5zdGFuY2UgZm9yIGEgbmV3IHByb2Nlc3MsIHdoaWNoIGlzIGdvaW5nIHRvIGJlIHNwYXduZWRcbiAqIG9uIFNpbXVsYXRvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFRoZSBVRElEIG9mIGFuIGV4aXN0aW5nIFNpbXVsYXRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IGFyZ3MgLSBTcGF3biBhcmd1bWVudHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBlbnYgW3t9XSAtIEFkZGl0aW9uYWwgZW52aXJvbm1lbnQgdmFyaWFibGVzIG1hcHBpbmcuXG4gKiBAcmV0dXJuIHtTdWJQcm9jZXNzfSBUaGUgaW5zdGFuY2Ugb2YgdGhlIHByb2Nlc3MgdG8gYmUgc3Bhd25lZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3Bhd25TdWJQcm9jZXNzICh1ZGlkLCBhcmdzLCBlbnYgPSB7fSkge1xuICByZXR1cm4gYXdhaXQgc2ltU3ViUHJvY2Vzcygnc3Bhd24nLCAwLCBbdWRpZCwgLi4uKF8uaXNBcnJheShhcmdzKSA/IGFyZ3MgOiBbYXJnc10pXSwgZW52KTtcbn1cblxuLyoqXG4gKiBPcGVuIFVSTCBzY2hlbWUgb24gU2ltdWxhdG9yLiBpT1Mgd2lsbCBhdXRvbWF0aWNhbGx5IHRyeVxuICogdG8gZmluZCBhIG1hdGNoaW5nIGFwcGxpY2F0aW9uLCB3aGljaCBzdXBwb3J0cyB0aGUgZ2l2ZW4gc2NoZW1lLlxuICogSXQgaXMgcmVxdWlyZWQgdGhhdCBTaW11bGF0b3IgaXMgaW4gX2Jvb3RlZF8gc3RhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgVURJRCBvZiBhbiBleGlzdGluZyBTaW11bGF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIFVSTCBzY2hlbWUgdG8gb3BlbiwgZm9yIGV4YW1wbGUgaHR0cDovL2FwcGlvbS5pb1xuICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgb3BlbmVkIGJ5IHRoZSBidWlsdC1pbiBtb2JpbGUgYnJvd3Nlci5cbiAqIEByZXR1cm4ge0V4ZWNSZXN1bHR9IENvbW1hbmQgZXhlY3V0aW9uIHJlc3VsdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gb3BlblVybCAodWRpZCwgdXJsKSB7XG4gIHJldHVybiBhd2FpdCBzaW1FeGVjKCdvcGVudXJsJywgMCwgW3VkaWQsIHVybF0pO1xufVxuXG4vKipcbiAqIEludm9rZSBoaWRkZW4gYXBwaW5mbyBzdWJjb21tYW5kIHRvIGdldCB0aGUgaW5mb3JtYXRpb25cbiAqIGFib3V0IGFwcGxpY2F0aW9ucyBpbnN0YWxsZWQgb24gU2ltdWxhdG9yLCBpbmNsdWRpbmdcbiAqIHN5c3RlbSBhcHBsaWNhdGlvbnMgKHtAbGluayBnZXRBcHBDb250YWluZXJ9IGRvZXMgbm90IFwic2VlXCIgc3VjaCBhcHBzKS5cbiAqIFNpbXVsYXRvciBzZXJ2ZXIgc2hvdWxkIGJlIGluICdib290ZWQnIHN0YXRlIGZvciB0aGlzIGNhbGwgdG8gd29yayBwcm9wZXJseS5cbiAqIFRoZSB0b29sIGlzIG9ubHkgYXZhaWxhYmxlIHNpbmNlIFhjb2RlIFNESyA4LjFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFVESUQgb2YgdGhlIHRhcmdldCBTaW11bGF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gYnVuZGxlSWQgLSBUaGUgYnVuZGxlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCBhcHBsaWNhdGlvbi5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGluZm9ybWF0aW9uIGFib3V0IGluc3RhbGxlZCBhcHBsaWNhdGlvbi5cbiAqXG4gKiBFeGFtcGxlIG91dHB1dCBmb3Igbm9uLWV4aXN0aW5nIGFwcGxpY2F0aW9uIGNvbnRhaW5lcjpcbiAqIDxwcmU+XG4gKiB7XG4gKiAgIENGQnVuZGxlSWRlbnRpZmllciA9IFwiY29tLmFwcGxlLk1vYmlsZVNhZmFyaVwiO1xuICogICBHcm91cENvbnRhaW5lcnMgPSAgICAge1xuICogICB9O1xuICogICBTQkFwcFRhZ3MgPSAgICAgKFxuICogICApO1xuICogfVxuICogPC9wcmU+XG4gKlxuICogRXhhbXBsZSBvdXRwdXQgZm9yIGFuIGV4aXN0aW5nIHN5c3RlbSBhcHBsaWNhdGlvbiBjb250YWluZXI6XG4gKiA8cHJlPlxuICoge1xuICogICBBcHBsaWNhdGlvblR5cGUgPSBIaWRkZW47XG4gKiAgIEJ1bmRsZSA9IFwiZmlsZTovLy9BcHBsaWNhdGlvbnMvWGNvZGUtYmV0YS5hcHAvQ29udGVudHMvRGV2ZWxvcGVyL1BsYXRmb3Jtcy9pUGhvbmVPUy5wbGF0Zm9ybS9EZXZlbG9wZXIvTGlicmFyeS9Db3JlU2ltdWxhdG9yL1Byb2ZpbGVzL1J1bnRpbWVzL2lPUy5zaW1ydW50aW1lL0NvbnRlbnRzL1Jlc291cmNlcy9SdW50aW1lUm9vdC9TeXN0ZW0vTGlicmFyeS9Db3JlU2VydmljZXMvU3ByaW5nQm9hcmQuYXBwXCI7XG4gKiAgIENGQnVuZGxlRGlzcGxheU5hbWUgPSBTcHJpbmdCb2FyZDtcbiAqICAgQ0ZCdW5kbGVFeGVjdXRhYmxlID0gU3ByaW5nQm9hcmQ7XG4gKiAgIENGQnVuZGxlSWRlbnRpZmllciA9IFwiY29tLmFwcGxlLnNwcmluZ2JvYXJkXCI7XG4gKiAgIENGQnVuZGxlTmFtZSA9IFNwcmluZ0JvYXJkO1xuICogICBDRkJ1bmRsZVZlcnNpb24gPSA1MDtcbiAqICAgR3JvdXBDb250YWluZXJzID0gICAgIHtcbiAqICAgfTtcbiAqICAgUGF0aCA9IFwiL0FwcGxpY2F0aW9ucy9YY29kZS1iZXRhLmFwcC9Db250ZW50cy9EZXZlbG9wZXIvUGxhdGZvcm1zL2lQaG9uZU9TLnBsYXRmb3JtL0RldmVsb3Blci9MaWJyYXJ5L0NvcmVTaW11bGF0b3IvUHJvZmlsZXMvUnVudGltZXMvaU9TLnNpbXJ1bnRpbWUvQ29udGVudHMvUmVzb3VyY2VzL1J1bnRpbWVSb290L1N5c3RlbS9MaWJyYXJ5L0NvcmVTZXJ2aWNlcy9TcHJpbmdCb2FyZC5hcHBcIjtcbiAqICAgU0JBcHBUYWdzID0gICAgIChcbiAqICAgKTtcbiAqIH1cbiAqIDwvcHJlPlxuICovXG5hc3luYyBmdW5jdGlvbiBhcHBJbmZvICh1ZGlkLCBidW5kbGVJZCkge1xuICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHNpbUV4ZWMoJ2FwcGluZm8nLCAwLCBbdWRpZCwgYnVuZGxlSWRdKTtcbiAgcmV0dXJuIChzdGRvdXQgfHwgJycpLnRyaW0oKTtcbn1cblxuLyoqXG4gKiBBZGQgdGhlIHBhcnRpY3VsYXIgbWVkaWEgZmlsZSB0byBTaW11bGF0b3IncyBsaWJyYXJ5LlxuICogSXQgaXMgcmVxdWlyZWQgdGhhdCBTaW11bGF0b3IgaXMgaW4gX2Jvb3RlZF8gc3RhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgVURJRCBvZiBhbiBleGlzdGluZyBTaW11bGF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIEZ1bGwgcGF0aCB0byBhIG1lZGlhIGZpbGUgb24gdGhlIGxvY2FsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgc3lzdGVtLlxuICogQHJldHVybiB7RXhlY1Jlc3VsdH0gQ29tbWFuZCBleGVjdXRpb24gcmVzdWx0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb3JyZXNwb25kaW5nIHNpbWN0bCBzdWJjb21tYW5kIGNvbW1hbmRcbiAqICAgICAgICAgICAgICAgICByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiBhZGRNZWRpYSAodWRpZCwgcGF0aCkge1xuICByZXR1cm4gYXdhaXQgc2ltRXhlYygnYWRkbWVkaWEnLCAwLCBbdWRpZCwgcGF0aF0pO1xufVxuXG4vKipcbiAqIFRlcm1pbmF0ZSB0aGUgZ2l2ZW4gcnVubmluZyBhcHBsaWNhdGlvbiBvbiBTaW11bGF0b3IuXG4gKiBJdCBpcyByZXF1aXJlZCB0aGF0IFNpbXVsYXRvciBpcyBpbiBfYm9vdGVkXyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFRoZSBVRElEIG9mIGFuIGV4aXN0aW5nIFNpbXVsYXRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBidW5kbGVJZCAtIEJ1bmRsZSBpZGVudGlmaWVyIG9mIHRoZSBhcHBsaWNhdGlvbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGlzIGdvaW5nIHRvIGJlIHRlcm1pbmF0ZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRlcm1pbmF0ZSAodWRpZCwgYnVuZGxlSWQpIHtcbiAgYXdhaXQgc2ltRXhlYygndGVybWluYXRlJywgMCwgW3VkaWQsIGJ1bmRsZUlkXSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmdWxsIHBhdGggdG8gdGhlIHBhcnRpY3VsYXIgYXBwbGljYXRpb24gY29udGFpbmVyXG4gKiBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0uIE5vdGUsIHRoYXQgdGhpcyBzdWJjb21tYW5kIHRocm93c1xuICogYW4gZXJyb3IgaWYgYnVuZGxlIGlkIG9mIGEgc3lzdGVtIGFwcGxpY2F0aW9uIGlzIHByb3ZpZGVkLFxuICogbGlrZSAnY29tLmFwcGxlLnNwcmluZ2JvYXJkJy5cbiAqIEl0IGlzIHJlcXVpcmVkIHRoYXQgU2ltdWxhdG9yIGlzIGluIF9ib290ZWRfIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIC0gVGhlIFVESUQgb2YgYW4gZXhpc3RpbmcgU2ltdWxhdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGJ1bmRsZUlkIC0gQnVuZGxlIGlkZW50aWZpZXIgb2YgYW4gYXBwbGljYXRpb24uXG4gKiBAcGFyYW0gez9ib29sZWFufSBsb2dFcnJvcnMgW3RydWVdIC0gV2hldGhlciB0byBpbmNsdWRlIGV4ZWMncyBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RkZXJyIG91dHB1dCBpbnRvIGV4Y2VwdGlvbiBtZXNzYWdlIGlmIHRocm93bi5cbiAqIEBwYXJhbSB7P3N0cmluZ30gY29udGFpbmVyVHlwZSAtIFdoaWNoIGNvbnRhaW5lciB0eXBlIHRvIHJldHVybi4gUG9zc2libGUgdmFsdWVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgJ2FwcCcsICdkYXRhJywgJ2dyb3VwcycsICc8QSBzcGVjaWZpYyBBcHAgR3JvdXAgY29udGFpbmVyPicuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAnYXBwJy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb24gdGhlIGxvY2FsXG4gKiAgICAgICAgICAgICAgICAgIGZpbGUgc3lzdGVtLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb3JyZXNwb25kaW5nIHNpbWN0bCBzdWJjb21tYW5kIGNvbW1hbmRcbiAqICAgICAgICAgICAgICAgICByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRBcHBDb250YWluZXIgKHVkaWQsIGJ1bmRsZUlkLCBsb2dFcnJvcnMgPSB0cnVlLCBjb250YWluZXJUeXBlID0gbnVsbCkge1xuICBjb25zdCBhcmdzID0gW3VkaWQsIGJ1bmRsZUlkXTtcbiAgaWYgKGNvbnRhaW5lclR5cGUpIHtcbiAgICBhcmdzLnB1c2goY29udGFpbmVyVHlwZSk7XG4gIH1cbiAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBzaW1FeGVjKCdnZXRfYXBwX2NvbnRhaW5lcicsIDAsIGFyZ3MsIHt9LCBsb2dFcnJvcnMpO1xuICByZXR1cm4gKHN0ZG91dCB8fCAnJykudHJpbSgpO1xufVxuXG4vKipcbiAqIFNodXRkb3duIHRoZSBnaXZlbiBTaW11bGF0b3IgaWYgaXQgaXMgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFRoZSBVRElEIG9mIGFuIGV4aXN0aW5nIFNpbXVsYXRvci5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2h1dGRvd24gKHVkaWQpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzaW1FeGVjKCdzaHV0ZG93bicsIDAsIFt1ZGlkXSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICghKGVyciArICcnKS5pbmNsdWRlcygnY3VycmVudCBzdGF0ZTogU2h1dGRvd24nKSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBsb2cuZGVidWcoYFNpbXVsYXRvciBhbHJlYWR5IGluICdTaHV0ZG93bicgc3RhdGUuIENvbnRpbnVpbmdgKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBTaW11bGF0b3IgZGV2aWNlIHdpdGggZ2l2ZW4gbmFtZSBmb3IgdGhlIHBhcnRpY3VsYXJcbiAqIHBsYXRmb3JtIHR5cGUgYW5kIHZlcnNpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgZGV2aWNlIG5hbWUgdG8gYmUgY3JlYXRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXZpY2VUeXBlSWQgLSBEZXZpY2UgdHlwZSwgZm9yIGV4YW1wbGUgJ2lQaG9uZSA2Jy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBydW50aW1lSWQgLSBQbGF0Zm9ybSB2ZXJzaW9uLCBmb3IgZXhhbXBsZSAnMTAuMycuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBbMTAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pdCBkZXZpY2UgY3JlYXRpb24gaXMgY29tcGxldGVkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgVURJRCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBkZXZpY2UuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZURldmljZSAobmFtZSwgZGV2aWNlVHlwZUlkLCBydW50aW1lSWQsIHRpbWVvdXQgPSAxMDAwMCkge1xuICBsZXQgdWRpZDtcbiAgLy8gZmlyc3QgbWFrZSBzdXJlIHRoYXQgdGhlIHJ1bnRpbWUgaWQgaXMgdGhlIHJpZ2h0IG9uZVxuICAvLyBpbiBzb21lIHZlcnNpb25zIG9mIFhjb2RlIGl0IHdpbGwgYmUgYSBwYXRjaCB2ZXJzaW9uXG4gIHRyeSB7XG4gICAgcnVudGltZUlkID0gYXdhaXQgZ2V0UnVudGltZUZvclBsYXRmb3JtVmVyc2lvbihydW50aW1lSWQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgVW5hYmxlIHRvIGZpbmQgcnVudGltZSBmb3IgaU9TICcke3J1bnRpbWVJZH0nLiBDb250aW51aW5nYCk7XG4gIH1cblxuICBsb2cuZGVidWcoYENyZWF0aW5nIHNpbXVsYXRvciB3aXRoIG5hbWUgJyR7bmFtZX0nLCBkZXZpY2UgdHlwZSBpZCAnJHtkZXZpY2VUeXBlSWR9JyBhbmQgcnVudGltZSBpZCAnJHtydW50aW1lSWR9J2ApO1xuICB0cnkge1xuICAgIGxldCBvdXQgPSBhd2FpdCBzaW1FeGVjKCdjcmVhdGUnLCAwLCBbbmFtZSwgZGV2aWNlVHlwZUlkLCBydW50aW1lSWRdKTtcbiAgICB1ZGlkID0gb3V0LnN0ZG91dC50cmltKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxldCByZWFzb24gPSBlcnIubWVzc2FnZTtcbiAgICBpZiAoZXJyLnN0ZGVycikge1xuICAgICAgcmVhc29uID0gZXJyLnN0ZGVyci50cmltKCk7XG4gICAgfVxuICAgIGxvZy5lcnJvckFuZFRocm93KGBDb3VsZCBub3QgY3JlYXRlIHNpbXVsYXRvciB3aXRoIG5hbWUgJyR7bmFtZX0nLCBkZXZpY2UgYCArXG4gICAgICAgICAgICAgICAgICAgICAgYHR5cGUgaWQgJyR7ZGV2aWNlVHlwZUlkfScgYW5kIHJ1bnRpbWUgaWQgJyR7cnVudGltZUlkfScuIFJlYXNvbjogJyR7cmVhc29ufSdgKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB0aGF0IGl0IGdldHMgb3V0IG9mIHRoZSBcIkNyZWF0aW5nXCIgc3RhdGVcbiAgbGV0IHJldHJpZXMgPSBwYXJzZUludCh0aW1lb3V0IC8gMTAwMCwgMTApO1xuICBhd2FpdCByZXRyeUludGVydmFsKHJldHJpZXMsIDEwMDAsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IGdldERldmljZXMoKTtcbiAgICBmb3IgKGxldCBkZXZpY2VBcnIgb2YgXy52YWx1ZXMoZGV2aWNlcykpIHtcbiAgICAgIGZvciAobGV0IGRldmljZSBvZiBkZXZpY2VBcnIpIHtcbiAgICAgICAgaWYgKGRldmljZS51ZGlkID09PSB1ZGlkKSB7XG4gICAgICAgICAgaWYgKGRldmljZS5zdGF0ZSA9PT0gJ0NyZWF0aW5nJykge1xuICAgICAgICAgICAgLy8gbmVlZCB0byByZXRyeVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZXZpY2Ugc3RpbGwgYmVpbmcgY3JlYXRlZCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzdG9wIGxvb2tpbmcsIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB1ZGlkO1xufVxuXG4vKipcbiAqIERlbGV0ZSB0aGUgcGFydGljdWxhciBTaW11bGF0b3IgZnJvbSBhdmFpbGFibGUgZGV2aWNlcyBsaXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIC0gVGhlIFVESUQgb2YgYW4gZXhpc3RpbmcgU2ltdWxhdG9yLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb3JyZXNwb25kaW5nIHNpbWN0bCBzdWJjb21tYW5kIGNvbW1hbmRcbiAqICAgICAgICAgICAgICAgICByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiBkZWxldGVEZXZpY2UgKHVkaWQpIHtcbiAgYXdhaXQgc2ltRXhlYygnZGVsZXRlJywgMCwgW3VkaWRdKTtcbn1cblxuLyoqXG4gKiBSZXNldCB0aGUgY29udGVudCBhbmQgc2V0dGluZ3Mgb2YgdGhlIHBhcnRpY3VsYXIgU2ltdWxhdG9yLlxuICogSXQgaXMgcmVxdWlyZWQgdGhhdCBTaW11bGF0b3IgaXMgaW4gX3NodXRkb3duXyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFRoZSBVRElEIG9mIGFuIGV4aXN0aW5nIFNpbXVsYXRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IFsxMDAwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml0IGRldmljZSByZXNldCBpcyBjb21wbGV0ZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVyYXNlRGV2aWNlICh1ZGlkLCB0aW1lb3V0ID0gMTAwMCkge1xuICBsZXQgbG9vcEZuID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHNpbUV4ZWMoJ2VyYXNlJywgMTAwMDAsIFt1ZGlkXSk7XG4gIH07XG4gIC8vIHJldHJ5IGVyYXNlIHdpdGggYSBzbGVlcCBpbiBiZXR3ZWVuIGJlY2F1c2UgaXQncyBmbGFrZXlcbiAgbGV0IHJldHJpZXMgPSBwYXJzZUludCh0aW1lb3V0IC8gMjAwLCAxMCk7XG4gIGF3YWl0IHJldHJ5SW50ZXJ2YWwocmV0cmllcywgMjAwLCBsb29wRm4pO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERldmljZUluZm9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRldmljZSBuYW1lLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVkaWQgLSBUaGUgZGV2aWNlIFVESUQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBUaGUgY3VycmVudCBTaW11bGF0b3Igc3RhdGUsIGZvciBleGFtcGxlICdib290ZWQnIG9yICdzaHV0ZG93bicuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2RrIC0gVGhlIFNESyB2ZXJzaW9uLCBmb3IgZXhhbXBsZSAnMTAuMycuXG4gKi9cblxuLyoqXG4gKiBQYXJzZSB0aGUgbGlzdCBvZiBleGlzdGluZyBTaW11bGF0b3IgZGV2aWNlcyB0byByZXByZXNlbnRcbiAqIGl0IGFzIGNvbnZlbmllbnQgbWFwcGluZy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgbWFwcGluZy4gRWFjaCBrZXkgaXMgcGxhdGZvcm0gdmVyc2lvbixcbiAqICAgICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUgJzEwLjMnIGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBpcyBhblxuICogICAgICAgICAgICAgICAgICBhcnJheSBvZiB0aGUgbWF0Y2hpbmcge0BsaW5rIERldmljZUluZm99IGluc3RhbmNlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGV2aWNlc0J5UGFyc2luZyAoKSB7XG4gIC8vIGdldCB0aGUgbGlzdCBvZiBkZXZpY2VzXG4gIGxldCB7c3Rkb3V0fSA9IGF3YWl0IHNpbUV4ZWMoJ2xpc3QnLCAwLCBbJ2RldmljZXMnXSk7XG5cbiAgLy8gZXhwZWN0IHRvIGdldCBhIGxpc3RpbmcgbGlrZVxuICAvLyAtLSBpT1MgOC4xIC0tXG4gIC8vICAgICBpUGhvbmUgNHMgKDNDQTZFN0RELTIyMEUtNDVFNS1CNzE2LTFFOTkyQjNBNDI5QykgKFNodXRkb3duKVxuICAvLyAgICAgLi4uXG4gIC8vIC0tIGlPUyA4LjIgLS1cbiAgLy8gICAgIGlQaG9uZSA0cyAoQTk5RkZGQzMtOEUxOS00RENGLUI1ODUtN0Q5RDQ2QjRDMTZFKSAoU2h1dGRvd24pXG4gIC8vICAgICAuLi5cbiAgLy8gc28sIGdldCB0aGUgYC0tIGlPUyBYLlggLS1gIGxpbmUgdG8gZmluZCB0aGUgc2RrIChYLlgpXG4gIC8vIGFuZCB0aGUgcmVzdCBvZiB0aGUgbGlzdGluZyBpbiBvcmRlciB0byBsYXRlciBmaW5kIHRoZSBkZXZpY2VzXG4gIGxldCBkZXZpY2VTZWN0aW9uUmUgPSAvLS0gaU9TICguKykgLS0oXFxuXFxzezR9LispKi9tZztcbiAgbGV0IG1hdGNoZXMgPSBbXTtcbiAgbGV0IG1hdGNoID0gZGV2aWNlU2VjdGlvblJlLmV4ZWMoc3Rkb3V0KTtcblxuICAvLyBtYWtlIGFuIGVudHJ5IGZvciBlYWNoIHNkayB2ZXJzaW9uXG4gIHdoaWxlIChtYXRjaCAhPT0gbnVsbCkge1xuICAgIG1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgbWF0Y2ggPSBkZXZpY2VTZWN0aW9uUmUuZXhlYyhzdGRvdXQpO1xuICB9XG4gIGlmIChtYXRjaGVzLmxlbmd0aCA8IDEpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdygnQ291bGQgbm90IGZpbmQgZGV2aWNlIHNlY3Rpb24nKTtcbiAgfVxuXG4gIC8vIGdldCBhbGwgdGhlIGRldmljZXMgZm9yIGVhY2ggc2RrXG4gIGxldCBkZXZpY2VzID0ge307XG4gIGZvciAobWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGxldCBzZGsgPSBtYXRjaFsxXTtcbiAgICBkZXZpY2VzW3Nka10gPSBbXTtcbiAgICAvLyBzcGxpdCB0aGUgZnVsbCBtYXRjaCBpbnRvIGxpbmVzIGFuZCByZW1vdmUgdGhlIGZpcnN0XG4gICAgZm9yIChsZXQgbGluZSBvZiBtYXRjaFswXS5zcGxpdCgnXFxuJykuc2xpY2UoMSkpIHtcbiAgICAgIC8vIGEgbGluZSBpcyBzb21ldGhpbmcgbGlrZVxuICAgICAgLy8gICAgaVBob25lIDRzIChBOTlGRkZDMy04RTE5LTREQ0YtQjU4NS03RDlENDZCNEMxNkUpIChTaHV0ZG93bilcbiAgICAgIC8vIHJldHJpZXZlOlxuICAgICAgLy8gICBpUGhvbmUgNHNcbiAgICAgIC8vICAgQTk5RkZGQzMtOEUxOS00RENGLUI1ODUtN0Q5RDQ2QjRDMTZFXG4gICAgICAvLyAgIFNodXRkb3duXG4gICAgICBsZXQgbGluZVJlID0gLyhbXlxcc10uKykgXFwoKFxcdystLitcXHcrKVxcKSBcXCgoXFx3K1xccz9cXHcrKVxcKS87IC8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvbEc3bUs2LzNcbiAgICAgIGxldCBsaW5lTWF0Y2ggPSBsaW5lUmUuZXhlYyhsaW5lKTtcbiAgICAgIGlmIChsaW5lTWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgbWF0Y2ggbGluZTogJHtsaW5lfWApO1xuICAgICAgfVxuICAgICAgLy8gc2F2ZSB0aGUgd2hvbGUgdGhpbmcgYXMgYWIgb2JqZWN0IGluIHRoZSBsaXN0IGZvciB0aGlzIHNka1xuXG4gICAgICBkZXZpY2VzW3Nka10ucHVzaCh7XG4gICAgICAgIG5hbWU6IGxpbmVNYXRjaFsxXSxcbiAgICAgICAgdWRpZDogbGluZU1hdGNoWzJdLFxuICAgICAgICBzdGF0ZTogbGluZU1hdGNoWzNdLFxuICAgICAgICBzZGssXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGV2aWNlcztcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgbGlzdCBvZiBleGlzdGluZyBTaW11bGF0b3IgZGV2aWNlcyB0byByZXByZXNlbnRcbiAqIGl0IGFzIGNvbnZlbmllbnQgbWFwcGluZyBmb3IgdGhlIHBhcnRpY3VsYXIgcGxhdGZvcm0gdmVyc2lvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9yU2RrIFtudWxsXSAtIFRoZSBwbGF0Zm9ybSB2ZXJzaW9uLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3Igd2hpY2ggdGhlIGRldmljZXMgbGlzdCBzaG91bGQgYmUgcGFyc2VkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSAnMTAuMycuXG4gKiBAcmV0dXJuIHtPYmplY3R8QXJyYXk8RGV2aWNlSW5mbz59IElmIF9mb3JTZGtfIGlzIHNldCB0aGVuIHRoZSBsaXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGRldmljZXMgZm9yIHRoZSBwYXJ0aWN1bGFyIHBsYXRmb3JtIHZlcnNpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE90aGVyd2lzZSB0aGUgc2FtZSByZXN1bHQgYXMgZm9yIHtAbGluayBnZXREZXZpY2VzQnlQYXJzaW5nfVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZSBvciBpZiBubyBtYXRjaGluZ1xuICogICAgICAgICAgICAgICAgIHBsYXRmb3JtIHZlcnNpb24gaXMgZm91bmQgaW4gdGhlIHN5c3RlbS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGV2aWNlcyAoZm9yU2RrID0gbnVsbCkge1xuICBsZXQgZGV2aWNlcztcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBzaW1FeGVjKCdsaXN0JywgMCwgWydkZXZpY2VzJywgJy1qJ10pO1xuICAgIC8qIEpTT04gc2hvdWxkIGJlXG4gICAgICoge1xuICAgICAqICAgXCJkZXZpY2VzXCIgOiB7XG4gICAgICogICAgIFwiaU9TIDxzZGs+XCIgOiBbXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgXCJzdGF0ZVwiIDogXCJCb290ZWRcIixcbiAgICAgKiAgICAgICAgIFwiYXZhaWxhYmlsaXR5XCIgOiBcIihhdmFpbGFibGUpXCIsXG4gICAgICogICAgICAgICBcIm5hbWVcIiA6IFwiaVBob25lIDZcIixcbiAgICAgKiAgICAgICAgIFwidWRpZFwiIDogXCI3NUUzNDE0MC0xOEU4LTREMUEtOUY0NS1BQUM3MzVERjc1REZcIlxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgXVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkZXZpY2VzID0ge307XG4gICAgZm9yIChsZXQgW3Nka05hbWUsIGVudHJpZXNdIG9mIF8udG9QYWlycyhKU09OLnBhcnNlKHN0ZG91dCkuZGV2aWNlcykpIHtcbiAgICAgIGlmIChzZGtOYW1lLmluZGV4T2YoJ2lPUycpICE9PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IHNkayA9IHNka05hbWUucmVwbGFjZSgnaU9TICcsICcnKTtcbiAgICAgIGRldmljZXNbc2RrXSA9IGVudHJpZXMubWFwKChlbCkgPT4ge1xuICAgICAgICBkZWxldGUgZWwuYXZhaWxhYmlsaXR5O1xuICAgICAgICByZXR1cm4gey4uLmVsLCBzZGt9O1xuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZGVidWcoYFVuYWJsZSB0byBnZXQgSlNPTiBkZXZpY2UgbGlzdDogJHtlcnIubWVzc2FnZX1gKTtcbiAgICBsb2cuZGVidWcoJ0ZhbGxpbmcgYmFjayB0byBtYW51YWxseSBwYXJzaW5nJyk7XG4gICAgZGV2aWNlcyA9IGF3YWl0IGdldERldmljZXNCeVBhcnNpbmcoKTtcbiAgfVxuXG4gIC8vIGlmIGEgYGZvclNka2Agd2FzIHBhc3NlZCBpbiwgcmV0dXJuIG9ubHkgdGhlIGNvcnJlc3BvbmRpbmcgbGlzdFxuICBpZiAoZm9yU2RrKSB7XG4gICAgaWYgKCFkZXZpY2VzW2ZvclNka10pIHtcbiAgICAgIGxldCBlcnJNc2cgPSBgJyR7Zm9yU2RrfScgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2Ygc2ltY3RsIFNES3MuYDtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZVNES3MgPSBfLmtleXMoZGV2aWNlcyk7XG4gICAgICBlcnJNc2cgKz0gYXZhaWxhYmxlU0RLcy5sZW5ndGggP1xuICAgICAgICBgIE9ubHkgdGhlIGZvbGxvd2luZyBTaW11bGF0b3IgU0RLIHZlcnNpb25zIGFyZSBhdmFpbGFibGUgb24geW91ciBzeXN0ZW06ICR7YXZhaWxhYmxlU0RLcy5qb2luKCcsICcpfWAgOlxuICAgICAgICBgIE5vIFNpbXVsYXRvciBTREsgdmVyc2lvbnMgYXJlIGF2YWlsYWJsZSBvbiB5b3VyIHN5c3RlbS4gUGxlYXNlIGluc3RhbGwgc29tZSB2aWEgWGNvZGUgcHJlZmVyZW5jZXMuYDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgIH1cbiAgICByZXR1cm4gZGV2aWNlc1tmb3JTZGtdO1xuICB9XG5cbiAgLy8gb3RoZXJ3aXNlIHJldHVybiBldmVyeXRoaW5nXG4gIHJldHVybiBkZXZpY2VzO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcnVudGltZSBmb3IgdGhlIHBhcnRpY3VsYXIgcGxhdGZvcm0gdmVyc2lvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGxhdGZvcm1WZXJzaW9uIC0gVGhlIHBsYXRmb3JtIHZlcnNpb24gbmFtZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSAnMTAuMycuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb3JyZXNwb25kaW5nIHJ1bnRpbWUgbmFtZSBmb3IgdGhlIGdpdmVuXG4gKiAgICAgICAgICAgICAgICAgIHBsYXRmb3JtIHZlcnNpb24uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFJ1bnRpbWVGb3JQbGF0Zm9ybVZlcnNpb24gKHBsYXRmb3JtVmVyc2lvbikge1xuICB0cnkge1xuICAgIC8vIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ3hjcnVuJywgWydzaW1jdGwnLCAnbGlzdCcsICdydW50aW1lcyddKTtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBzaW1FeGVjKCdsaXN0JywgMCwgWydydW50aW1lcyddKTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHN0ZG91dC5zcGxpdCgnXFxuJykpIHtcbiAgICAgIGxldCBtYXRjaCA9IElPU19SVU5USU1FX1JFR0VYUC5leGVjKGxpbmUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmIChtYXRjaFsxXSA9PT0gcGxhdGZvcm1WZXJzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoWzJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChpZ24pIHt9XG5cbiAgLy8gaWYgbm90aGluZyB3YXMgZm91bmQsIHBhc3MgcGxhdGZvcm0gdmVyc2lvbiBiYWNrXG4gIHJldHVybiBwbGF0Zm9ybVZlcnNpb247XG59XG5cbi8qKlxuICogR2V0cyBiYXNlNjQgc2NyZWVuc2hvdCBmb3IgZGV2aWNlICh4Y29kZSA+PSA4LjEgb25seSkuXG4gKiBJdCBpcyByZXF1aXJlZCB0aGF0IFNpbXVsYXRvciBpcyBpbiBfYm9vdGVkXyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFRoZSBVRElEIG9mIGFuIGV4aXN0aW5nIFNpbXVsYXRvci5cbiAqIEByZXR1cm4ge3N0cmluZ30gQmFzZTY0LWVuY29kZWQgU2ltdWxhdG9yIHNjcmVlbnNob3QuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFNjcmVlbnNob3QgKHVkaWQpIHtcbiAgbGV0IHBhdGhUb1NjcmVlbnNob3RQbmcgPSBhd2FpdCB0ZW1wRGlyLnBhdGgoe3ByZWZpeDogYHNjcmVlbnNob3QtJHt1ZGlkfWAsIHN1ZmZpeDogJy5wbmcnfSk7XG4gIGF3YWl0IHNpbUV4ZWMoJ2lvJywgMCwgW3VkaWQsICdzY3JlZW5zaG90JywgcGF0aFRvU2NyZWVuc2hvdFBuZ10pO1xuICBsZXQgc2NyZWVuc2hvdEltZyA9IGF3YWl0IGZzLnJlYWRGaWxlKHBhdGhUb1NjcmVlbnNob3RQbmcpO1xuICBhd2FpdCBmcy5yaW1yYWYocGF0aFRvU2NyZWVuc2hvdFBuZyk7XG4gIHJldHVybiBzY3JlZW5zaG90SW1nLnRvU3RyaW5nKCdiYXNlNjQnKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbnRlbnQgb2YgU2ltdWxhdG9yIHBhc3RlYm9hcmQgKHhjb2RlID49IDguMSBvbmx5KS5cbiAqIEl0IGlzIHJlcXVpcmVkIHRoYXQgU2ltdWxhdG9yIGlzIGluIF9ib290ZWRfIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIC0gRGV2aWNlIFVESUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIFRoZSBhY3R1YWwgc3RyaW5nIGNvbnRlbnQgdG8gYmUgc2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIFsndXRmLTgnXSAtIFRoZSBlbmNvZGluZyBvZiB0aGUgZ2l2ZW4gcGFzdGVib2FyZCBjb250ZW50LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVURi04IGJ5IGRlZmF1bHQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNldFBhc3RlYm9hcmQgKHVkaWQsIGNvbnRlbnQsIGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICBjb25zdCBwYkNvcHlTdWJwcm9jZXNzID0gbmV3IFN1YlByb2Nlc3MoJ3hjcnVuJywgWydzaW1jdGwnLCAncGJjb3B5JywgdWRpZF0pO1xuICBhd2FpdCBwYkNvcHlTdWJwcm9jZXNzLnN0YXJ0KDApO1xuICBjb25zdCBleGl0Q29kZVZlcmlmaWVyID0gcGJDb3B5U3VicHJvY2Vzcy5qb2luKCk7XG4gIGNvbnN0IHN0ZGluID0gcGJDb3B5U3VicHJvY2Vzcy5wcm9jLnN0ZGluO1xuICBzdGRpbi5zZXRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN0ZGluLndyaXRlKGNvbnRlbnQpO1xuICBzdGRpbi5lbmQoKTtcbiAgYXdhaXQgZXhpdENvZGVWZXJpZmllcjtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvbnRlbnQgb2YgU2ltdWxhdG9yIHBhc3RlYm9hcmQgKHhjb2RlID49IDguMSBvbmx5KS5cbiAqIEl0IGlzIHJlcXVpcmVkIHRoYXQgU2ltdWxhdG9yIGlzIGluIF9ib290ZWRfIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIC0gRGV2aWNlIFVESUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgWyd1dGYtOCddIC0gVGhlIGVuY29kaW5nIG9mIHRoZSByZXR1cm5lZCBwYXN0ZWJvYXJkIGNvbnRlbnQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVVRGLTggYnkgZGVmYXVsdC5cbiAqIEByZXR1cm4ge3N0cmluZ30gQ3VycmVudCBjb250ZW50IG9mIFNpbXVsYXRvciBwYXN0ZWJvYXJkIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UGFzdGVib2FyZCAodWRpZCwgZW5jb2RpbmcgPSAndXRmLTgnKSB7XG4gIGNvbnN0IGFyZ3MgPSBbJ3NpbWN0bCcsICdwYnBhc3RlJywgdWRpZF07XG4gIHRyeSB7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKCd4Y3J1bicsIGFyZ3MsIHt0aW1lb3V0OiAwLCBlbmNvZGluZ30pO1xuICAgIHJldHVybiBzdGRvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5zdGRlcnIpIHtcbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGBFcnJvciBydW5uaW5nICd4Y3J1biAke2FyZ3Muam9pbignICcpfSc6ICR7ZS5zdGRlcnIudHJpbSgpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuZXJyb3JBbmRUaHJvdyhlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIGxpc3Qgb2YgZGV2aWNlIHR5cGVzIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBYY29kZSBpbnN0YWxsYXRpb25cbiAqXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBMaXN0IG9mIHRoZSB0eXBlcyBvZiBkZXZpY2VzIGF2YWlsYWJsZVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb3JyZXNwb25kaW5nIHNpbWN0bCBjb21tYW5kIGZhaWxzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldERldmljZVR5cGVzICgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHNpbUV4ZWMoJ2xpc3QnLCAwLCBbJ2RldmljZXR5cGVzJywgJy1qJ10pO1xuICAgIC8qXG4gICAgICogSlNPTiB3aWxsIGJlIGxpa2U6XG4gICAgICogICB7XG4gICAgICogICAgIFwiZGV2aWNldHlwZXNcIiA6IFtcbiAgICAgKiAgICAgICB7XG4gICAgICogICAgICAgICBcIm5hbWVcIiA6IFwiaVBob25lIDRzXCIsXG4gICAgICogICAgICAgICBcImlkZW50aWZpZXJcIiA6IFwiY29tLmFwcGxlLkNvcmVTaW11bGF0b3IuU2ltRGV2aWNlVHlwZS5pUGhvbmUtNHNcIlxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgICAgLi4uXG4gICAgICogICB9XG4gICAgICovXG4gICAgY29uc3QgZGV2aWNlVHlwZXMgPSBKU09OLnBhcnNlKHN0ZG91dC50cmltKCkpO1xuICAgIHJldHVybiBkZXZpY2VUeXBlcy5kZXZpY2V0eXBlcy5tYXAoKHR5cGUpID0+IHR5cGUubmFtZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxldCBtc2cgPSBgVW5hYmxlIHRvIGdldCBsaXN0IG9mIGRldmljZSB0eXBlczogJHtlcnIubWVzc2FnZX1gO1xuICAgIGlmIChlcnIuc3RkZXJyKSB7XG4gICAgICBtc2cgPSBgJHttc2d9LiBTdGRlcnI6ICR7ZXJyLnN0ZGVycn1gO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJvb3RNb25pdG9yT3B0aW9uc1xuICogQHByb3BlcnR5IHs/bnVtYmVyfSB0aW1lb3V0IFsyNDAwMDBdIC0gU2ltdWxhdG9yIGJvb3RpbmcgdGltZW91dCBpbiBtcy5cbiAqIEBwcm9wZXJ0eSB7P0Z1bmN0aW9ufSBvbldhaXRpbmdEYXRhTWlncmF0aW9uIC0gVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGRhdGEgbWlncmF0aW9uIHN0YWdlIHN0YXJ0cy5cbiAqIEBwcm9wZXJ0eSB7P0Z1bmN0aW9ufSBvbldhaXRpbmdTeXN0ZW1BcHAgLSBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gc3lzdGVtIGFwcCB3YWl0IHN0YWdlIHN0YXJ0cy5cbiAqIEBwcm9wZXJ0eSB7P0Z1bmN0aW9ufSBvbkZpbmlzaGVkIC0gVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIFNpbXVsYXRvciBpcyBmdWxseSBib290ZWQuXG4gKiBAcHJvcGVydHkgez9GdW5jdGlvbn0gb25FcnJvciAtIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbW9uaXRvcmluZyB0aGUgYm9vdGluZyBwcm9jZXNzXG4gKiBvciB3aGVuIHRoZSB0aW1lb3V0IGhhcyBleHBpcmVkLlxuICovXG5cbi8qKlxuICogU3RhcnQgbW9uaXRvcmluZyBmb3IgYm9vdCBzdGF0dXMgb2YgdGhlIHBhcnRpY3VsYXIgU2ltdWxhdG9yLlxuICogSWYgb25GaW5pc2hlZCBwcm9wZXJ0eSBpcyBub3Qgc2V0IHRoZW4gdGhlIG1ldGhvZCB3aWxsIGJsb2NrXG4gKiB1bnRpbCBTaW11bGF0b3IgYm9vdGluZyBpcyBjb21wbGV0ZWQuXG4gKiBUaGUgbWV0aG9kIGlzIG9ubHkgYXZhaWxhYmxlIHNpbmNlIFhjb2RlOC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIERldmljZSBVRElELlxuICogQHBhcmFtIHs/Qm9vdE1vbml0b3JPcHRpb25zfSBvcHRzIC0gTW9uaXRvcmluZyBvcHRpb25zLlxuICogQHJldHVybnMge1N1YlByb2Nlc3N9IFRoZSBpbnN0YW5jZSBvZiB0aGUgY29ycmVzcG9uZGluZyBtb25pdG9yaW5nIHByb2Nlc3MuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIFNpbXVsYXRvciBmYWlscyB0byBmaW5pc2ggYm9vdGluZyB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQgYW5kIG9uRmluaXNoZWRcbiAqIHByb3BlcnR5IGlzIG5vdCBzZXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN0YXJ0Qm9vdE1vbml0b3IgKHVkaWQsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdGltZW91dCA9IDI0MDAwMCxcbiAgICBvbldhaXRpbmdEYXRhTWlncmF0aW9uLFxuICAgIG9uV2FpdGluZ1N5c3RlbUFwcCxcbiAgICBvbkZpbmlzaGVkLFxuICAgIG9uRXJyb3IsXG4gIH0gPSBvcHRzO1xuXG4gIGxldCBzdGF0dXMgPSAnJztcbiAgbGV0IGlzQm9vdGluZ0ZpbmlzaGVkID0gZmFsc2U7XG4gIGxldCBlcnJvciA9IG51bGw7XG4gIGxldCB0aW1lb3V0SGFuZGxlciA9IG51bGw7XG4gIGNvbnN0IGJvb3RNb25pdG9yID0gYXdhaXQgc2ltU3ViUHJvY2VzcygnYm9vdHN0YXR1cycsIDAsIFt1ZGlkXSk7XG4gIGJvb3RNb25pdG9yLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICBzdGF0dXMgKz0gc3Rkb3V0IHx8IHN0ZGVycjtcbiAgICBpZiAoc3Rkb3V0KSB7XG4gICAgICBpZiAoc3Rkb3V0LmluY2x1ZGVzKCdXYWl0aW5nIG9uIERhdGEgTWlncmF0aW9uJykgJiYgb25XYWl0aW5nRGF0YU1pZ3JhdGlvbikge1xuICAgICAgICBvbldhaXRpbmdEYXRhTWlncmF0aW9uKCk7XG4gICAgICB9IGVsc2UgaWYgKHN0ZG91dC5pbmNsdWRlcygnV2FpdGluZyBvbiBTeXN0ZW0gQXBwJykgJiYgb25XYWl0aW5nU3lzdGVtQXBwKSB7XG4gICAgICAgIG9uV2FpdGluZ1N5c3RlbUFwcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGJvb3RNb25pdG9yLm9uKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgIGlmICh0aW1lb3V0SGFuZGxlcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgIGlmIChvbkZpbmlzaGVkKSB7XG4gICAgICAgIG9uRmluaXNoZWQoKTtcbiAgICAgIH1cbiAgICAgIGlzQm9vdGluZ0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdHVzID0gc3RhdHVzIHx8IHNpZ25hbDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKHN0YXR1cyk7XG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBhd2FpdCBib290TW9uaXRvci5zdGFydCgwKTtcbiAgY29uc3Qgc3RvcE1vbml0b3IgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGJvb3RNb25pdG9yLmlzUnVubmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgYm9vdE1vbml0b3Iuc3RvcCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cud2FybihlLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgdGltZVN0YXJ0ZWQgPSBwcm9jZXNzLmhydGltZSgpO1xuICBpZiAob25GaW5pc2hlZCkge1xuICAgIHRpbWVvdXRIYW5kbGVyID0gc2V0VGltZW91dChzdG9wTW9uaXRvciwgdGltZW91dCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oKCkgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNCb290aW5nRmluaXNoZWQ7XG4gICAgICB9LCB7d2FpdE1zOiB0aW1lb3V0LCBpbnRlcnZhbE1zOiA1MDB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGF3YWl0IHN0b3BNb25pdG9yKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzaW11bGF0b3IgJHt1ZGlkfSBoYXMgZmFpbGVkIHRvIGZpbmlzaCBib290aW5nIGFmdGVyICR7cHJvY2Vzcy5ocnRpbWUodGltZVN0YXJ0ZWQpWzBdfXMuIGAgK1xuICAgICAgICBgT3JpZ2luYWwgc3RhdHVzOiAke3N0YXR1c31gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvb3RNb25pdG9yO1xufVxuXG5cbmV4cG9ydCB7XG4gIGluc3RhbGxBcHAsIHJlbW92ZUFwcCwgbGF1bmNoLCBzcGF3biwgc3Bhd25TdWJQcm9jZXNzLCBvcGVuVXJsLCB0ZXJtaW5hdGUsXG4gIHNodXRkb3duLCBjcmVhdGVEZXZpY2UsIGdldEFwcENvbnRhaW5lciwgZ2V0U2NyZWVuc2hvdCwgZGVsZXRlRGV2aWNlLFxuICBlcmFzZURldmljZSwgZ2V0RGV2aWNlcywgZ2V0UnVudGltZUZvclBsYXRmb3JtVmVyc2lvbiwgYm9vdERldmljZSxcbiAgc2V0UGFzdGVib2FyZCwgZ2V0UGFzdGVib2FyZCwgYWRkTWVkaWEsIGFwcEluZm8sIGdldERldmljZVR5cGVzLFxuICBzdGFydEJvb3RNb25pdG9yLFxufTtcbiJdLCJmaWxlIjoibGliL3NpbWN0bC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
